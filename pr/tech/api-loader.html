<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>low-code 模式下的数据接入方案 | xiujava</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="jiawen 的博客">
    
    <link rel="preload" href="/pr/assets/css/0.styles.3978be1e.css" as="style"><link rel="preload" href="/pr/assets/js/app.b652a85f.js" as="script"><link rel="preload" href="/pr/assets/js/2.846b7fc6.js" as="script"><link rel="preload" href="/pr/assets/js/1.bc703a74.js" as="script"><link rel="preload" href="/pr/assets/js/43.5ec06833.js" as="script"><link rel="prefetch" href="/pr/assets/js/10.afb24a76.js"><link rel="prefetch" href="/pr/assets/js/11.26a4e38a.js"><link rel="prefetch" href="/pr/assets/js/12.972428b2.js"><link rel="prefetch" href="/pr/assets/js/13.363a2818.js"><link rel="prefetch" href="/pr/assets/js/14.da87bb03.js"><link rel="prefetch" href="/pr/assets/js/15.be6c279e.js"><link rel="prefetch" href="/pr/assets/js/16.5b27973e.js"><link rel="prefetch" href="/pr/assets/js/17.e9441626.js"><link rel="prefetch" href="/pr/assets/js/18.73cc4e61.js"><link rel="prefetch" href="/pr/assets/js/19.04ead57f.js"><link rel="prefetch" href="/pr/assets/js/20.a59fc3ba.js"><link rel="prefetch" href="/pr/assets/js/21.08fe35aa.js"><link rel="prefetch" href="/pr/assets/js/22.f5ce9d9e.js"><link rel="prefetch" href="/pr/assets/js/23.47ca722c.js"><link rel="prefetch" href="/pr/assets/js/24.4fddcd23.js"><link rel="prefetch" href="/pr/assets/js/25.633c1faa.js"><link rel="prefetch" href="/pr/assets/js/26.8ab83674.js"><link rel="prefetch" href="/pr/assets/js/27.182bd1ad.js"><link rel="prefetch" href="/pr/assets/js/28.1383b35a.js"><link rel="prefetch" href="/pr/assets/js/29.ae522b2f.js"><link rel="prefetch" href="/pr/assets/js/3.7d9825a9.js"><link rel="prefetch" href="/pr/assets/js/30.bcb96b1e.js"><link rel="prefetch" href="/pr/assets/js/31.dc8342be.js"><link rel="prefetch" href="/pr/assets/js/32.1dc6f5da.js"><link rel="prefetch" href="/pr/assets/js/33.c22b5273.js"><link rel="prefetch" href="/pr/assets/js/34.8897cec6.js"><link rel="prefetch" href="/pr/assets/js/35.5dcb8c21.js"><link rel="prefetch" href="/pr/assets/js/36.11dde236.js"><link rel="prefetch" href="/pr/assets/js/37.fbdf6108.js"><link rel="prefetch" href="/pr/assets/js/38.6c386453.js"><link rel="prefetch" href="/pr/assets/js/39.bbbe93e7.js"><link rel="prefetch" href="/pr/assets/js/4.1b5a2940.js"><link rel="prefetch" href="/pr/assets/js/40.fa8a4a55.js"><link rel="prefetch" href="/pr/assets/js/41.1337de57.js"><link rel="prefetch" href="/pr/assets/js/42.974b0c08.js"><link rel="prefetch" href="/pr/assets/js/44.41d4f968.js"><link rel="prefetch" href="/pr/assets/js/45.74b1a5a1.js"><link rel="prefetch" href="/pr/assets/js/46.0b447bda.js"><link rel="prefetch" href="/pr/assets/js/47.bbf6f3b2.js"><link rel="prefetch" href="/pr/assets/js/48.4e4341c7.js"><link rel="prefetch" href="/pr/assets/js/49.b676e821.js"><link rel="prefetch" href="/pr/assets/js/5.0d0d8c0c.js"><link rel="prefetch" href="/pr/assets/js/50.89ce29be.js"><link rel="prefetch" href="/pr/assets/js/51.5d694e00.js"><link rel="prefetch" href="/pr/assets/js/52.9da5a600.js"><link rel="prefetch" href="/pr/assets/js/53.3a609c95.js"><link rel="prefetch" href="/pr/assets/js/54.c2aa27ca.js"><link rel="prefetch" href="/pr/assets/js/55.7e92886a.js"><link rel="prefetch" href="/pr/assets/js/56.b2bd260a.js"><link rel="prefetch" href="/pr/assets/js/57.bc7fc028.js"><link rel="prefetch" href="/pr/assets/js/58.0b9ba301.js"><link rel="prefetch" href="/pr/assets/js/59.30303c2b.js"><link rel="prefetch" href="/pr/assets/js/6.ec95ead8.js"><link rel="prefetch" href="/pr/assets/js/60.05f954c6.js"><link rel="prefetch" href="/pr/assets/js/7.aa392645.js"><link rel="prefetch" href="/pr/assets/js/vendors~docsearch.5e19b665.js">
    <link rel="stylesheet" href="/pr/assets/css/0.styles.3978be1e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/pr/" class="home-link router-link-active"><!----> <span class="site-name">xiujava</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/pr/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://www.yuque.com/xiwen-bxuha/pr/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  yuque
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/javaxiu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/pr/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://www.yuque.com/xiwen-bxuha/pr/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  yuque
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/javaxiu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>NLP</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Electron系列</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>低代码系列</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>技术分享</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pr/pr/tech/scroll-bar.html" class="sidebar-link">双滚动条的滚动逻辑</a></li><li><a href="/pr/pr/tech/figma_dev_mode.html" class="sidebar-link">figma devmode</a></li><li><a href="/pr/pr/tech/figma_2_code.html" class="sidebar-link">figma导出代码</a></li><li><a href="/pr/pr/tech/ts-trick.html" class="sidebar-link">TS抽取组件描述</a></li><li><a href="/pr/pr/tech/typescript.html" class="sidebar-link">typescript 巧技</a></li><li><a href="/pr/pr/tech/api-loader.html" aria-current="page" class="active sidebar-link">low-code 模式下的数据接入方案</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pr/pr/tech/api-loader.html#背景" class="sidebar-link">背景</a></li><li class="sidebar-sub-header"><a href="/pr/pr/tech/api-loader.html#设计思路" class="sidebar-link">设计思路</a></li><li class="sidebar-sub-header"><a href="/pr/pr/tech/api-loader.html#前端如何实现" class="sidebar-link">前端如何实现</a></li><li class="sidebar-sub-header"><a href="/pr/pr/tech/api-loader.html#实践方案-api-loader" class="sidebar-link">实践方案 api-loader</a></li><li class="sidebar-sub-header"><a href="/pr/pr/tech/api-loader.html#平台化到-no-code" class="sidebar-link">平台化到 no-code</a></li><li class="sidebar-sub-header"><a href="/pr/pr/tech/api-loader.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/pr/pr/tech/google_workspace.html" class="sidebar-link">Google Workspace add-ons</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>杂谈</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="low-code-模式下的数据接入方案"><a href="#low-code-模式下的数据接入方案" class="header-anchor">#</a> low-code 模式下的数据接入方案</h1> <h2 id="背景"><a href="#背景" class="header-anchor">#</a> 背景</h2> <p>最近都在提一个概念：<a href="https://www.forbes.com/sites/jasonbloomberg/2018/07/30/low-codeno-code-hpapaas-heres-what-everybody-is-missing/#27c722c33ac0" target="_blank" rel="noopener noreferrer">low-code<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。个人认为，low-code 基本上可以等量理解为 &quot;write less do more&quot; ，跟当年python提的概念如出一辙。本质上都是将一些功能稳健具有原子性的单元模块，通过一种新的简化而又健壮的编程范式按需调用起来。回顾汇编到C，C 到 python，Java 到 groovy，html 到 react，tcp 到 http，大多如此：放弃一定的灵活性，带来更便捷的使用体验，以达到 low-code / write less do more 的目的。
而 no-code 呢？本质上并非真的没有代码，而是将一部分预设的 low-code 做成模板，然后将这些模板做成可视化工具，让外行人也能轻易拖拽组合起来。Photoshop/sketch 的脚本、曾经的 Dreamweaver 都是如此</p> <p>本文从前端到服务端的接口开发方式，来探讨一种新的 low-code 接口实践方式，首先先抛出来几个现有的问题：</p> <h3 id="几个问题"><a href="#几个问题" class="header-anchor">#</a> 几个问题</h3> <ol><li>繁琐重复且极容易写出复杂混乱的接口对接代码，例如<a href="https://yuque.antfin-inc.com/docs/share/fce34cfb-33d7-4f12-9a4b-5e3aadd0b13e" target="_blank" rel="noopener noreferrer">这个例子<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>开发时期没有自动根据类型自动mock能力，需要手动修改函数借助额外工具和额外语法</li> <li>接口对接代码阅读体验差，难以确定请求参数、返回数据格式</li> <li>缺乏自动数据校验：简单的类型校验、空值校验、<a href="https://www.atatech.org/articles/137442?flag_data_from=home_follow_user_article" target="_blank" rel="noopener noreferrer">规范性质的约定校验<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><strong>多端(pc/桌面/移动端/小程序)多类型(jsonp/ajax/tcp)接口请求各成方案，没有一致的开发/阅读体验。经常需要重复开发某个类型能力的请求工具(如epass/mtop/小程序)</strong></li></ol> <p>现在有一些工具类的东西也提了一些概念，例如 superagent 的 agent 概念，axios 的 interceptors 概念， natty-fetch 的命名空间，这些工具配合一些手写的代码也许可以解决以上问题的部分，但不能全部解决，尤其是3、5这两个问题。这些新的概念也不能简化问题。</p> <h2 id="设计思路"><a href="#设计思路" class="header-anchor">#</a> 设计思路</h2> <h3 id="如何看待接口这个问题的本质"><a href="#如何看待接口这个问题的本质" class="header-anchor">#</a> 如何看待接口这个问题的本质</h3> <p>所谓接口，应该是一个高度抽象的信息流交换口的描述。也即：它接受什么样的输入，会有什么样的输出。而它真正从哪儿来，到哪儿出，从来不是也不应该是接口关心的问题。接受这个概念之后，反观物理世界的网口、USB；Java 里的 interface，都是这个概念，它们也都被称之为接口。
  接口应该是这样一个概念：<strong>只关心入参、返回值</strong>，但<strong>不关心实现</strong>，这个模型其实就可以被理解为这样一个抽象函数</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// 该函数并不需要body</span>
<span class="token keyword">function</span> <span class="token function">getData</span><span class="token punctuation">(</span>param1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> param2<span class="token operator">:</span> SomeNestStruct<span class="token punctuation">)</span><span class="token operator">:</span> SomeDataStruct<span class="token punctuation">;</span>
</code></pre></div><p>看着有点别扭，没有body，这个函数怎么跑起来？比如它从哪个url来？它通过ajax还是jsonp来？
  这里我们回顾一下上面的原则，从哪儿来，什么协议来的，这并不是接口需要关心的。因此这些信息应该是接口的属性，也即你的水龙头是塑料的还是铁的(协议)，是从水厂来的还是水桶来的(数据来源)，这属于它本身的属性，属于给人理解和程序理解的部分。作为附属属性，放到函数描述才是最佳做法。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">/**
 * @url http://path
 * @protocal ajax
**/</span>
<span class="token keyword">function</span> <span class="token function">getData</span><span class="token punctuation">(</span>param1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> param2<span class="token operator">:</span> SomeNestStruct<span class="token punctuation">)</span><span class="token operator">:</span> SomeDataStruct<span class="token punctuation">;</span>
</code></pre></div><p>再回来看看这些信息是否足够了呢？足够了。理论要素都已经具备，程序就应可以运作起来。(暂且不考虑在现有编程体系它是否可以直接运行)
  这个运作过程虽然是独立思考的结果，但这个模式并非首创。spring data jpa 就是个这样的例子</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Query</span><span class="token punctuation">(</span><span class="token string">&quot;select h.city as city, h.name as name, avg(r.rating) as averageRating from Hotel h left outer join h.reviews r where h.city = ?1 group by h&quot;</span><span class="token punctuation">)</span>
<span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HotelSummary</span><span class="token punctuation">&gt;</span></span> <span class="token function">findByCity</span><span class="token punctuation">(</span><span class="token class-name">City</span> city<span class="token punctuation">,</span> <span class="token class-name">Pageable</span> pageable<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>甚至它还有更极致的做法，根据函数名来自动生成 sql</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">findFirst10ByLastname</span><span class="token punctuation">(</span><span class="token class-name">String</span> lastname<span class="token punctuation">,</span> <span class="token class-name">Sort</span> sort<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>spring data jpa 的这个设计非常优雅而且简单易用，通过长久的 java 服务端开发积累，各种方言驱动(mysql/oracle/mssql)已经逐渐可以忽略，面向的是常见的分页查询、连表查询、分组查询等常见 CRUD 模型，放弃了一些灵活度高但是不常用的操作(但并不是彻底放弃，通过高级 api 仍然可以使用)，以达到低代码开发的良好体验。从这个角度讲，我们设计的模式跟它也是基本类似的。基于这套推导的理论，我们设计一套能够解决开篇抛出来的问题的方案。</p> <h3 id="问题应对方案"><a href="#问题应对方案" class="header-anchor">#</a> 问题应对方案</h3> <p>针对几个问题，逐一列举我们需要的要素</p> <ul><li>自动 mock /自动校验：模拟数据，需要有一套能够在运行时使用的<strong>类型系统</strong>。用来描述基础数据类型、复杂嵌套数据类型。基于类型描述即可自动模拟数据</li> <li>代码阅读体验：上一节我们推导出来的要素，如果抛弃了复杂的实现，<strong>仅需要编写接口</strong>，这个问题自然有效解决</li> <li>多端多协议：和 spring data jpa 一样，屏蔽方言，这些交给驱动层(driver)翻译和执行。使用层也就不必考虑它背后是 mqtt 还是裸的 tcp，或者是 ajax/jsop 之类的。</li></ul> <h3 id="还能做更多吗"><a href="#还能做更多吗" class="header-anchor">#</a> 还能做更多吗</h3> <p>go deep. 考虑业务场景，我们 ajax 通常常不是裸着用的例如：</p> <ul><li>配合一些高阶协议。例如 mtop。</li> <li>数据结构处理，每个团队的可能都不一样，需要做一次适配(adapt)例如</li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code>resp <span class="token operator">=</span> <span class="token punctuation">{</span>
  success<span class="token operator">:</span> <span class="token boolean">true</span><span class="token operator">/</span><span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token comment">//有的可能叫data</span>
  content<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 有的可能叫err或者message</span>
  errMsg<span class="token operator">:</span> <span class="token builtin">string</span>
  errCode<span class="token operator">:</span> <span class="token number">0</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>返回值轻度纠正，例如代码可能写<code>data.a.b</code>这样深层调用，明显这存在空指针风险，一般获取到数据后会处理：<code>if (data.a not exist) then data.a = defaultValue</code>;</li> <li>入参检查：防止传了错误值、空值到服务端，导致没必要的故障</li> <li>出参检查：方式服务端返回错误数据格式，导致前端出现各种 unexpected exception</li></ul> <p>以上这些问题，本身并不属于获取协议/数据源之类的配置的问题，它应该是接口中的数据流节点的问题，即中间件(middleware)。因此我们可以进阶的对函数这样描述</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">/**
 * @url http://path
 * @protocal ajax
 * @pipe paramCheck &gt; ajax &gt; adapt &gt; returnCheck
**/</span>
<span class="token keyword">function</span> <span class="token function">getData</span><span class="token punctuation">(</span>param1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> param2<span class="token operator">:</span> SomeNestStruct<span class="token punctuation">)</span><span class="token operator">:</span> SomeDataStruct<span class="token punctuation">;</span>
</code></pre></div><p>这样写清楚多了，也能描述清楚问题了。但是阅读起来似乎有一种把逻辑放到注释里去的头重脚轻的感觉。其实开发时也根本不考虑这么多，不在乎数据从哪儿来，经过了哪儿，只看它最后是什么。为此，我们稍作简化流程，将一组middleware的组合管道流抽象为“一种数据获取方式”，别名 <strong>kind</strong>。类似 nodejs-express 的 handlers 概念，也类似 spring aop 的概念。由此上面的再简化为：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">/**
 * @url http://path
 * @kind mtop
**/</span>
<span class="token keyword">function</span> <span class="token function">getData</span><span class="token punctuation">(</span>param1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> param2<span class="token operator">:</span> SomeNestStruct<span class="token punctuation">)</span><span class="token operator">:</span> SomeDataStruct<span class="token punctuation">;</span>
</code></pre></div><p>这里的 <code>mtop</code> 描述实际上就是<code>paramCheck &gt; ajax &gt; adapt &gt; returnCheck</code>这一组流程的串联。</p> <h2 id="前端如何实现"><a href="#前端如何实现" class="header-anchor">#</a> 前端如何实现</h2> <p>上述都是在讲接口如何抽象，这套设计方案从理论上是可行的。以下基于前端视角来看这个模型如何在前端实施。
  整个方案更多的是围绕在数据类型和注释的问题上。为了避免自造一套类型系统增加学习成本，我们可以考虑直接使用现在比较流行的 <strong>typescript</strong>。
  但是ts存在一个问题：typescript 并非运行时语言，它的类型信息和注释不是 js 的元素，编译成 js 后会被丢弃，无法被运行时使用，因此此处考虑自行实现一套 typescript 的 ast 编译工具，将类型声明信息保留到运行时，在运行时再基于这些类型信息做mock、校验、函数体自动实现。
因此流程包含两个阶段：编译时（compiler）和运行时（runtime）</p> <h4 id="流程图"><a href="#流程图" class="header-anchor">#</a> 流程图</h4> <p><img src="/pr//yuque/0/2019/png/139763/1557332675164-ad40a0be-291e-4b90-847c-4902de8959c9.png" alt=""></p> <h4 id="编译时"><a href="#编译时" class="header-anchor">#</a> 编译时</h4> <p>编译时将 typescript 中书写的类名、函数名、入参类型、返回值类型、注释获取并注入代码中；并根据注释中一个特定配置(@kind)决定请求的流程是问题5中的哪一种并生成对应的代码</p> <h4 id="运行时"><a href="#运行时" class="header-anchor">#</a> 运行时</h4> <p>函数被调用（请求被触发）时，执行特定请求（例如ajax）的各个步骤（middleware），例如：入参检查-&gt;真实ajax请求-&gt;返回值检查-&gt;返回值格式化。</p> <h2 id="实践方案-api-loader"><a href="#实践方案-api-loader" class="header-anchor">#</a> 实践方案 api-loader</h2> <p>基于上面的理论和设计方案，<a href="https://yuque.antfin-inc.com/recore/api-loader/help" target="_blank" rel="noopener noreferrer">api-loader<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>是我们的一个实践</p> <h3 id="定位和优势"><a href="#定位和优势" class="header-anchor">#</a> 定位和优势</h3> <h4 id="定位"><a href="#定位" class="header-anchor">#</a> 定位</h4> <p>这套方案的最终目的是为了提升开发体验和效率 (low-code)，同时在业务中逐步积累数据请求协议，让这些协议可以被逐步枚举，直到可以覆盖掉90%业务场景下的 request / response 模型的请求。
  另外，基于其中的类型系统，<a href="https://www.atatech.org/articles/137442?flag_data_from=home_follow_user_article" target="_blank" rel="noopener noreferrer">数据模型的一致性<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>也会通过类似这样的库 <a href="https://web.npm.alibaba-inc.com/package/@ali/xux-types" target="_blank" rel="noopener noreferrer">xux-types<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 来逐步规整，沉淀成标准类型声明代码库。</p> <h4 id="优势"><a href="#优势" class="header-anchor">#</a> 优势</h4> <ol><li>开发体验：阅读简单，没有复杂的层层调用</li> <li>开发提速：根据类型自动 mock，极大提升联调接口前的开发效率</li> <li>开发提效：利用 ts 的阅读高效性，可以得到丰富的编译器代码提示、注释提示、编译警告等</li> <li>开发提效：数据检查会自动发现潜在的类型信息问题，提升接口数据问题排查效率，避免空值、字段大小写错误这类低级错误</li> <li><strong>技术收敛</strong>：同一类型的请求(ipc协议/tcp协议/ajax)等等，可以一次开发，提交 middleware 库之后0成本复用。</li></ol> <h2 id="平台化到-no-code"><a href="#平台化到-no-code" class="header-anchor">#</a> 平台化到 no-code</h2> <p>大量的接口管理，需要一个统一的接口管理平台去维护，这个平台上具备5个基础能力：接口自动化测试、数据模拟、接口文档、服务沉淀、描述与代码互转。</p> <ul><li>接口自动化测试：模拟前端动作，向服务端发起压力测试、边界 case 测试、故障 case 测试等</li> <li>数据模拟：业务服务端未就绪时的 simulation</li> <li>接口文档：文档化管理平台</li> <li>能力沉淀：常用通用的业务服务，通过这个平台了解到前后端组合带来了哪些领域、哪些业务、哪些产品的模块。基于这些结果，我们将其再作为业务组件能力发布，可以被快速检索，可以被快速接入到新产品中。</li> <li>描述与代码互转：这里包含三个角色：平台，服务端，前端，这三者的接口描述关系是可以互转的
<img src="/pr//yuque/0/2019/svg/139763/1557332675161-0a6f1f9f-036f-4a5d-84d2-98a656adb565.svg" alt=""></li></ul> <p>在这个接口平台之上，构建数据模型描述(元数据)，创建数据操作(接口)，配合灵犀等数据到视图映射的工具，达到 low-code 甚至 no-code 的应用构建目的，也正如开篇提的 Dreamweaver 一类的工具了。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>说到底，程序应该是一套人机交互语言，是“让计算机能确切知道你想干什么”的描述语言，同时，也应具备“人类也能轻易阅读和理解”。在这个前提之下去构建一种 low-code，避免程序难处理、人也读不懂的局面。继而，构建no-code应用。
  但是用户的使用体验是反过来的。先体验 no-code，希望做一些定制化的诉求时进入 low-code 的使用。到一定的专业程度，则会考虑专业的开发方式 pro-code，开发一些专业的单元模块，反哺 low-code 的能力单元，继而丰富 no-code 的能力。
  在本文提到的前端接口方案表现的案例就是：使用平台配置接口 -&gt; 低代码手动调用各种 middleware 串联 -&gt; 贡献 middleware (例如接口协议) -&gt; 丰富平台功能模块
<a href="https://www.atatech.org/articles/137897" target="_blank" rel="noopener noreferrer"><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/pr/pr/tech/typescript.html" class="prev">
        typescript 巧技
      </a></span> <span class="next"><a href="/pr/pr/tech/google_workspace.html">
        Google Workspace add-ons
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/pr/assets/js/app.b652a85f.js" defer></script><script src="/pr/assets/js/2.846b7fc6.js" defer></script><script src="/pr/assets/js/1.bc703a74.js" defer></script><script src="/pr/assets/js/43.5ec06833.js" defer></script>
  </body>
</html>
