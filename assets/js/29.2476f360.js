(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{310:function(a,t,n){"use strict";n.r(t);var r=n(14),s=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"飞书客户端技术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#飞书客户端技术"}},[a._v("#")]),a._v(" 飞书客户端技术")]),a._v(" "),t("h2",{attrs:{id:"背景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[a._v("#")]),a._v(" 背景")]),a._v(" "),t("p",[a._v("在前⽂从业务⻆度对阿⾥郎与⻜书做了⼀个对⽐之后，本⽂主要从技术⻆度，看我们和⻜书分别是如何答\n题的。两者基本框架都是基于 Electron，⼀个⽤ web 技术栈实现的 PC 端应⽤框架。此前已经有对于\nElectron 在阿⾥郎⾥的应⽤经验也有⼀些总结")]),a._v(" "),t("h2",{attrs:{id:"多窗口管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多窗口管理"}},[a._v("#")]),a._v(" 多窗⼝管理")]),a._v(" "),t("p",[a._v("由于 Electron 可视化部分是基于 Web 窗⼝ (BrowserWindow) 来实现的，所以并不能像 native ⼀样去\n创建多个相同 context 的视图 (view) ，每个窗⼝都是⼀个独⽴的 web ⻚⾯。所以即便要写的只是⼀个像\n钉消息那种桌⾯⼩窗⼝，也需要单独实现⼀个 web。这样带来的问题就是如何管理多个 web ⼯程代码。\n很现实的⼀个⼩例⼦：如果我在要实现钉消息⾥⾯显示当前⽤户名，(新⼿)开发者就容易不经思考顺其⾃然的从主窗⼝的代码中 import user。⽽⼀些复杂的场景下，例如⼀些底层基础调⽤、和主进程的通信逻辑，很可能就会促使各独⽴ web 之间有很多相似的东⻄，让⼯程之间变得更含混不清。\n在这个问题背景下，⻜书的解决办法是标准的 Electron 多窗⼝，也就是标准的多个 html + webpack 构\n建的 dist ⽬录。我们拿到的构建后的代码结构如下，包含图⽚预览、⼩程序、⽇程等窗⼝。\n在解决不同窗⼝（spa⼯程）之间重复代码利⽤的⽅式是建⽴ electron-common ⽂件夹和⼀个放了很多\n代码⽚段的 npm 私有库包 @byted/electron @bytesview/pc-sdk。这种管理⽅式会让⼈有个⼩疑惑：\n这么多的包和⽬录，新⼿上⼿成本如何，以及各包维护成本如何\n"),t("img",{attrs:{src:"/yuque/0/2021/png/139763/1637136922732-a808de7d-7b02-4938-af3c-8d6c785c81e5.png",alt:"image.png"}}),a._v(" "),t("img",{attrs:{src:"/yuque/0/2021/png/139763/1637136929573-c6c6fc0e-89ff-4a5e-a5f8-bb03b1ebbb47.png",alt:"image.png"}}),a._v("\n相对来看，在阿⾥郎⾥，多 spa ⼯程的结构⼀般使⽤在直播观看端、旧版主播端、云笔记。这类应⽤的特\n点是独⽴性较⾼，和阿⾥郎主体应⽤的直接关联较少。\n但这些独⽴应⽤后续从业务上如果需要做⼀些深度开发，⽐如云笔记要做离线存储、和⾳视频联动，就不\n可避免的要和主窗⼝⼀样具备⽂件io、 ipc 通信等基本底层能⼒。所以我们还是希望不同 spa 能保证⼀套\n统⼀的运⾏时 jsapi 环境。")]),a._v(" "),t("h2",{attrs:{id:"版本升级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#版本升级"}},[a._v("#")]),a._v(" 版本升级")]),a._v(" "),t("p",[a._v("Electron 框架开发的应⽤安装到⽤户机器上后，如果需要实现软件升级，Electron 内置了⼀个升级框架\nsquirrel 。⼤致原理是下载新的安装包到临时⽬录，然后提示⽤户重启或��动重启，重启时 fork 新进程将\n安装包替换到安装⽬录下。\n⻜书的版本升级设计了两种，⼀种是 asar 包升级，⼀种是整包升级，⽤的也是 squirrel。我的机器上经\n历过⼏次 asar 升级，⼤版本升级没⻅过。所以其实可以看出来，⻜书是以前者升级⽅式为主。\n资源升级从代码来看，基本包含 app.asar、Frameworks、app.asar.unpack 这三项，步骤是 检查升级\n-> 下载 zip 包 -> md5检查 -> 解压 zip -> 替换资源\n其中，zip 包下载和 md5 检查在代码中没找到，应该是某个独⽴窗⼝中的代码实现的。\n替换资源的步骤，是由 fork ⼀个 native 程序，让其在主程序退出后来做替换和重新拉起")]),a._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[a._v("app"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("windowManage"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("mainWindow"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("sendWebContents")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'auto-updater-download-start'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  version"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token literal-property property"}},[a._v("src")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" url"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token literal-property property"}},[a._v("dest")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" path\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),t("p",[t("img",{attrs:{src:"/yuque/0/2021/png/139763/1637137006647-ca7d4519-c0f1-4022-84fe-5110f6dd04fd.png",alt:"image.png"}}),a._v("\n⼤版本升级：包⽬录结构⾥包含 Squirrel.framework 就是使⽤了松⿏整包升级的标识")]),a._v(" "),t("p",[t("img",{attrs:{src:"/yuque/0/2021/png/139763/1637137018059-d90fdf56-701d-426c-8d55-99cc3a9dbd6c.png",alt:"image.png"}}),a._v("\n阿⾥郎曾经也做过热更新 asar 的实践，但是由于安全和稳定问题，该实践搁置了。但不管怎么说⾄少从\n⻜书上，我们看到这个⽅案的可⾏性。（顺带⼀提，我们集团的语雀客户端也有 asar 包升级的⽅式）")]),a._v(" "),t("h2",{attrs:{id:"前端与-native-协作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端与-native-协作"}},[a._v("#")]),a._v(" 前端与 native 协作")]),a._v(" "),t("p",[a._v("Electron 的纯前端能做的事情有限，有些⽐较底层的实现需要 c++ 配合，这个在阿⾥郎⾥是双进程的。\n双进程就只能依靠 IPC 通信来解决，这就导致偶尔会出现丢消息、前端进程正常运⾏native挂掉了连不上\n等问题。⻜书在这⽅⾯是怎么做的呢")]),a._v(" "),t("h3",{attrs:{id:"子进程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#子进程"}},[a._v("#")]),a._v(" ⼦进程")]),a._v(" "),t("p",[a._v("也就是⽤ nodejs api childProcess.exec/spawn 的⽅式来 fork ⼀个进程。这种⽅式⼀般是不需要通\n信，像⽤命令⾏⼀样只管⼊参和 stdio print 的。⻜书也有在使⽤，下⾯这些正好也是这种形式：\n截图功能：由于截图功能⽐较常⻅，都有简单可复⽤的⼩型独⽴程序可以⽀持，和业务耦合度相对较\n低，⼦进程完全可以⽀撑。\nAutoUpdater：需要被 fork ，作为独⽴程序才能实现在主程序退出之后能够继续运⾏，将安装包替换\n到安装⽬录下\n桌⾯通知：native 实现效果会更好，⽽且⼀般也不需要什么通信。被点击⼀下确认、超时隐藏，都算\n是进程结束")]),a._v(" "),t("h3",{attrs:{id:"node-addon"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node-addon"}},[a._v("#")]),a._v(" node addon")]),a._v(" "),t("p",[a._v("基于 nodejs 核⼼扩展 的⽅式, 将 c++ 编译为 .node ⽂件，这样 Electron 的 nodejs 部分就获得了\nc++ 的底层能⼒。这种⼀般⽤在轻量级系统 api 调⽤。⻜书⽤到了但不限于：")]),a._v(" "),t("ul",[t("li",[a._v("屏幕捕获。如⻜书投屏前有 N 个应⽤、N 个窗⼝预览的截图（base64），就是通过这种⽅式截取的")]),a._v(" "),t("li",[a._v("dock管理。mac 版本下让⼀个应⽤能有多个 dock 图标")]),a._v(" "),t("li",[a._v("WiFi。获取 WiFi 状态信息")]),a._v(" "),t("li",[a._v("grpc。基于 protobuf 的 rpc 通信库，c++ 编解码性能会更⾼⼀些")])]),a._v(" "),t("p",[t("img",{attrs:{src:"/yuque/0/2021/png/139763/1637137081881-58520bbf-cbbe-4096-91a4-34601f8d373d.png",alt:"image.png"}})]),a._v(" "),t("h3",{attrs:{id:"ffi-protobuf"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ffi-protobuf"}},[a._v("#")]),a._v(" ffi+protobuf")]),a._v(" "),t("p",[a._v("阿⾥郎⾳视频曾经做过⼀次⼤改版，原来是基于 Electron 的 webrtc 做视频流编解码传输，由于版本限制\n等⼀些问题，性能不够⾼，发热⼤。针对这个问题，后来的解决⽅法是把⾳视频、投屏全 native 化。⽽这\n个问题在⻜书⾥解决⽅式⾮常值得称赞。\n⻜书仍然是 Electron 架构，但是没有使⽤ Electron-Chrome 部分的⾳视频能⼒，⽽是⽤ c++ 写了编解\n码包，通过 ffi ⽅式链接给前端。在⾳视频会议、投屏、远程控制，都是使⽤的这种⽅式，流程图如下\n"),t("img",{attrs:{src:"/yuque/0/2021/png/139763/1637137151018-c26d7600-4aa8-4c9a-94df-e55af2fa6275.png",alt:"image.png"}}),a._v(" "),t("img",{attrs:{src:"/yuque/0/2021/png/139763/1637137160666-1376e9b5-438f-410e-87b1-1be99e80a16c.png",alt:"image.png"}})]),a._v(" "),t("p",[a._v("这样的架构，前端视觉部分既能使⽤ Electron 跨平台的能⼒（UI不⽤画两次，兼容性好），⼜能在编解码\n部分也是统⼀⼀套代码（C++ 编译成 dll for windows /dylib for mac，甚⾄还能 for android)。同时，\n由于上层都是 Electron，就根本不存在跨进程通信的问题。我们阿⾥郎当时在处理 Electron 和 ⾳视频/\n投屏 的 native 独⽴程序通信问题上花费了不少功夫。\n从这种架构设计来看，他们的组织架构可能是⼤前端+native 所以才能促成这种⽅案的实施？")]),a._v(" "),t("h2",{attrs:{id:"前端"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端"}},[a._v("#")]),a._v(" 前端")]),a._v(" "),t("p",[a._v("React16 + react-redux + immutable.\n每个⻚⾯⼀组 index.html + webpack.config.js 标准⼯程。这⾥应该没有太⼤的新意，都是能想到的标\n准前端开发套路")]),a._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),t("h3",{attrs:{id:"优"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优"}},[a._v("#")]),a._v(" 优")]),a._v(" "),t("p",[a._v("native 的协作处理的⾮常好，灵活根据不同场景使⽤ node addon / ffi / ⼦进程等⽅式，在跨平\n台、稳定性⽅⾯都有⾮常优秀的表现。")]),a._v(" "),t("h3",{attrs:{id:"缺"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缺"}},[a._v("#")]),a._v(" 缺")]),a._v(" "),t("p",[a._v("前端代码⼯程性不够好，代码⽚段式的 npm 包、多 spa ⼯程打包的⽅式，让其⼀致性不够好，应该\n会带来⼀些⼯程管理上的问题")])])}),[],!1,null,null,null);t.default=s.exports}}]);