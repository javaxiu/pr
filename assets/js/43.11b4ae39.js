(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{326:function(a,t,s){"use strict";s.r(t);var e=s(14),r=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"low-code-模式下的数据接入方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#low-code-模式下的数据接入方案"}},[a._v("#")]),a._v(" low-code 模式下的数据接入方案")]),a._v(" "),t("h2",{attrs:{id:"背景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[a._v("#")]),a._v(" 背景")]),a._v(" "),t("p",[a._v("最近都在提一个概念："),t("a",{attrs:{href:"https://www.forbes.com/sites/jasonbloomberg/2018/07/30/low-codeno-code-hpapaas-heres-what-everybody-is-missing/#27c722c33ac0",target:"_blank",rel:"noopener noreferrer"}},[a._v("low-code"),t("OutboundLink")],1),a._v('。个人认为，low-code 基本上可以等量理解为 "write less do more" ，跟当年python提的概念如出一辙。本质上都是将一些功能稳健具有原子性的单元模块，通过一种新的简化而又健壮的编程范式按需调用起来。回顾汇编到C，C 到 python，Java 到 groovy，html 到 react，tcp 到 http，大多如此：放弃一定的灵活性，带来更便捷的使用体验，以达到 low-code / write less do more 的目的。\n而 no-code 呢？本质上并非真的没有代码，而是将一部分预设的 low-code 做成模板，然后将这些模板做成可视化工具，让外行人也能轻易拖拽组合起来。Photoshop/sketch 的脚本、曾经的 Dreamweaver 都是如此')]),a._v(" "),t("p",[a._v("本文从前端到服务端的接口开发方式，来探讨一种新的 low-code 接口实践方式，首先先抛出来几个现有的问题：")]),a._v(" "),t("h3",{attrs:{id:"几个问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#几个问题"}},[a._v("#")]),a._v(" 几个问题")]),a._v(" "),t("ol",[t("li",[a._v("繁琐重复且极容易写出复杂混乱的接口对接代码，例如"),t("a",{attrs:{href:"https://yuque.antfin-inc.com/docs/share/fce34cfb-33d7-4f12-9a4b-5e3aadd0b13e",target:"_blank",rel:"noopener noreferrer"}},[a._v("这个例子"),t("OutboundLink")],1)]),a._v(" "),t("li",[a._v("开发时期没有自动根据类型自动mock能力，需要手动修改函数借助额外工具和额外语法")]),a._v(" "),t("li",[a._v("接口对接代码阅读体验差，难以确定请求参数、返回数据格式")]),a._v(" "),t("li",[a._v("缺乏自动数据校验：简单的类型校验、空值校验、"),t("a",{attrs:{href:"https://www.atatech.org/articles/137442?flag_data_from=home_follow_user_article",target:"_blank",rel:"noopener noreferrer"}},[a._v("规范性质的约定校验"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("strong",[a._v("多端(pc/桌面/移动端/小程序)多类型(jsonp/ajax/tcp)接口请求各成方案，没有一致的开发/阅读体验。经常需要重复开发某个类型能力的请求工具(如epass/mtop/小程序)")])])]),a._v(" "),t("p",[a._v("现在有一些工具类的东西也提了一些概念，例如 superagent 的 agent 概念，axios 的 interceptors 概念， natty-fetch 的命名空间，这些工具配合一些手写的代码也许可以解决以上问题的部分，但不能全部解决，尤其是3、5这两个问题。这些新的概念也不能简化问题。")]),a._v(" "),t("h2",{attrs:{id:"设计思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计思路"}},[a._v("#")]),a._v(" 设计思路")]),a._v(" "),t("h3",{attrs:{id:"如何看待接口这个问题的本质"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何看待接口这个问题的本质"}},[a._v("#")]),a._v(" 如何看待接口这个问题的本质")]),a._v(" "),t("p",[a._v("所谓接口，应该是一个高度抽象的信息流交换口的描述。也即：它接受什么样的输入，会有什么样的输出。而它真正从哪儿来，到哪儿出，从来不是也不应该是接口关心的问题。接受这个概念之后，反观物理世界的网口、USB；Java 里的 interface，都是这个概念，它们也都被称之为接口。\n  接口应该是这样一个概念："),t("strong",[a._v("只关心入参、返回值")]),a._v("，但"),t("strong",[a._v("不关心实现")]),a._v("，这个模型其实就可以被理解为这样一个抽象函数")]),a._v(" "),t("div",{staticClass:"language-typescript extra-class"},[t("pre",{pre:!0,attrs:{class:"language-typescript"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 该函数并不需要body")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("getData")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("param1"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("string")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" param2"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" SomeNestStruct"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" SomeDataStruct"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),t("p",[a._v("看着有点别扭，没有body，这个函数怎么跑起来？比如它从哪个url来？它通过ajax还是jsonp来？\n  这里我们回顾一下上面的原则，从哪儿来，什么协议来的，这并不是接口需要关心的。因此这些信息应该是接口的属性，也即你的水龙头是塑料的还是铁的(协议)，是从水厂来的还是水桶来的(数据来源)，这属于它本身的属性，属于给人理解和程序理解的部分。作为附属属性，放到函数描述才是最佳做法。")]),a._v(" "),t("div",{staticClass:"language-typescript extra-class"},[t("pre",{pre:!0,attrs:{class:"language-typescript"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/**\n * @url http://path\n * @protocal ajax\n**/")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("getData")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("param1"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("string")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" param2"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" SomeNestStruct"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" SomeDataStruct"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),t("p",[a._v("再回来看看这些信息是否足够了呢？足够了。理论要素都已经具备，程序就应可以运作起来。(暂且不考虑在现有编程体系它是否可以直接运行)\n  这个运作过程虽然是独立思考的结果，但这个模式并非首创。spring data jpa 就是个这样的例子")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Query")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"select h.city as city, h.name as name, avg(r.rating) as averageRating from Hotel h left outer join h.reviews r where h.city = ?1 group by h"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Page")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("HotelSummary")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("findByCity")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("City")]),a._v(" city"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Pageable")]),a._v(" pageable"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),t("p",[a._v("甚至它还有更极致的做法，根据函数名来自动生成 sql")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("List")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("User")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("findFirst10ByLastname")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" lastname"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Sort")]),a._v(" sort"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),t("p",[a._v("spring data jpa 的这个设计非常优雅而且简单易用，通过长久的 java 服务端开发积累，各种方言驱动(mysql/oracle/mssql)已经逐渐可以忽略，面向的是常见的分页查询、连表查询、分组查询等常见 CRUD 模型，放弃了一些灵活度高但是不常用的操作(但并不是彻底放弃，通过高级 api 仍然可以使用)，以达到低代码开发的良好体验。从这个角度讲，我们设计的模式跟它也是基本类似的。基于这套推导的理论，我们设计一套能够解决开篇抛出来的问题的方案。")]),a._v(" "),t("h3",{attrs:{id:"问题应对方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#问题应对方案"}},[a._v("#")]),a._v(" 问题应对方案")]),a._v(" "),t("p",[a._v("针对几个问题，逐一列举我们需要的要素")]),a._v(" "),t("ul",[t("li",[a._v("自动 mock /自动校验：模拟数据，需要有一套能够在运行时使用的"),t("strong",[a._v("类型系统")]),a._v("。用来描述基础数据类型、复杂嵌套数据类型。基于类型描述即可自动模拟数据")]),a._v(" "),t("li",[a._v("代码阅读体验：上一节我们推导出来的要素，如果抛弃了复杂的实现，"),t("strong",[a._v("仅需要编写接口")]),a._v("，这个问题自然有效解决")]),a._v(" "),t("li",[a._v("多端多协议：和 spring data jpa 一样，屏蔽方言，这些交给驱动层(driver)翻译和执行。使用层也就不必考虑它背后是 mqtt 还是裸的 tcp，或者是 ajax/jsop 之类的。")])]),a._v(" "),t("h3",{attrs:{id:"还能做更多吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#还能做更多吗"}},[a._v("#")]),a._v(" 还能做更多吗")]),a._v(" "),t("p",[a._v("go deep. 考虑业务场景，我们 ajax 通常常不是裸着用的例如：")]),a._v(" "),t("ul",[t("li",[a._v("配合一些高阶协议。例如 mtop。")]),a._v(" "),t("li",[a._v("数据结构处理，每个团队的可能都不一样，需要做一次适配(adapt)例如")])]),a._v(" "),t("div",{staticClass:"language-typescript extra-class"},[t("pre",{pre:!0,attrs:{class:"language-typescript"}},[t("code",[a._v("resp "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  success"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("true")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("false")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//有的可能叫data")]),a._v("\n  content"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 有的可能叫err或者message")]),a._v("\n  errMsg"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("string")]),a._v("\n  errCode"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("ul",[t("li",[a._v("返回值轻度纠正，例如代码可能写"),t("code",[a._v("data.a.b")]),a._v("这样深层调用，明显这存在空指针风险，一般获取到数据后会处理："),t("code",[a._v("if (data.a not exist) then data.a = defaultValue")]),a._v(";")]),a._v(" "),t("li",[a._v("入参检查：防止传了错误值、空值到服务端，导致没必要的故障")]),a._v(" "),t("li",[a._v("出参检查：方式服务端返回错误数据格式，导致前端出现各种 unexpected exception")])]),a._v(" "),t("p",[a._v("以上这些问题，本身并不属于获取协议/数据源之类的配置的问题，它应该是接口中的数据流节点的问题，即中间件(middleware)。因此我们可以进阶的对函数这样描述")]),a._v(" "),t("div",{staticClass:"language-typescript extra-class"},[t("pre",{pre:!0,attrs:{class:"language-typescript"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/**\n * @url http://path\n * @protocal ajax\n * @pipe paramCheck > ajax > adapt > returnCheck\n**/")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("getData")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("param1"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("string")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" param2"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" SomeNestStruct"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" SomeDataStruct"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),t("p",[a._v("这样写清楚多了，也能描述清楚问题了。但是阅读起来似乎有一种把逻辑放到注释里去的头重脚轻的感觉。其实开发时也根本不考虑这么多，不在乎数据从哪儿来，经过了哪儿，只看它最后是什么。为此，我们稍作简化流程，将一组middleware的组合管道流抽象为“一种数据获取方式”，别名 "),t("strong",[a._v("kind")]),a._v("。类似 nodejs-express 的 handlers 概念，也类似 spring aop 的概念。由此上面的再简化为：")]),a._v(" "),t("div",{staticClass:"language-typescript extra-class"},[t("pre",{pre:!0,attrs:{class:"language-typescript"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/**\n * @url http://path\n * @kind mtop\n**/")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("getData")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("param1"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("string")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" param2"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" SomeNestStruct"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" SomeDataStruct"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),t("p",[a._v("这里的 "),t("code",[a._v("mtop")]),a._v(" 描述实际上就是"),t("code",[a._v("paramCheck > ajax > adapt > returnCheck")]),a._v("这一组流程的串联。")]),a._v(" "),t("h2",{attrs:{id:"前端如何实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端如何实现"}},[a._v("#")]),a._v(" 前端如何实现")]),a._v(" "),t("p",[a._v("上述都是在讲接口如何抽象，这套设计方案从理论上是可行的。以下基于前端视角来看这个模型如何在前端实施。\n  整个方案更多的是围绕在数据类型和注释的问题上。为了避免自造一套类型系统增加学习成本，我们可以考虑直接使用现在比较流行的 "),t("strong",[a._v("typescript")]),a._v("。\n  但是ts存在一个问题：typescript 并非运行时语言，它的类型信息和注释不是 js 的元素，编译成 js 后会被丢弃，无法被运行时使用，因此此处考虑自行实现一套 typescript 的 ast 编译工具，将类型声明信息保留到运行时，在运行时再基于这些类型信息做mock、校验、函数体自动实现。\n因此流程包含两个阶段：编译时（compiler）和运行时（runtime）")]),a._v(" "),t("h4",{attrs:{id:"流程图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#流程图"}},[a._v("#")]),a._v(" 流程图")]),a._v(" "),t("p",[t("img",{attrs:{src:"/yuque/0/2019/png/139763/1557332675164-ad40a0be-291e-4b90-847c-4902de8959c9.png",alt:""}})]),a._v(" "),t("h4",{attrs:{id:"编译时"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编译时"}},[a._v("#")]),a._v(" 编译时")]),a._v(" "),t("p",[a._v("编译时将 typescript 中书写的类名、函数名、入参类型、返回值类型、注释获取并注入代码中；并根据注释中一个特定配置(@kind)决定请求的流程是问题5中的哪一种并生成对应的代码")]),a._v(" "),t("h4",{attrs:{id:"运行时"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运行时"}},[a._v("#")]),a._v(" 运行时")]),a._v(" "),t("p",[a._v("函数被调用（请求被触发）时，执行特定请求（例如ajax）的各个步骤（middleware），例如：入参检查->真实ajax请求->返回值检查->返回值格式化。")]),a._v(" "),t("h2",{attrs:{id:"实践方案-api-loader"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实践方案-api-loader"}},[a._v("#")]),a._v(" 实践方案 api-loader")]),a._v(" "),t("p",[a._v("基于上面的理论和设计方案，"),t("a",{attrs:{href:"https://yuque.antfin-inc.com/recore/api-loader/help",target:"_blank",rel:"noopener noreferrer"}},[a._v("api-loader"),t("OutboundLink")],1),a._v("是我们的一个实践")]),a._v(" "),t("h3",{attrs:{id:"定位和优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定位和优势"}},[a._v("#")]),a._v(" 定位和优势")]),a._v(" "),t("h4",{attrs:{id:"定位"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定位"}},[a._v("#")]),a._v(" 定位")]),a._v(" "),t("p",[a._v("这套方案的最终目的是为了提升开发体验和效率 (low-code)，同时在业务中逐步积累数据请求协议，让这些协议可以被逐步枚举，直到可以覆盖掉90%业务场景下的 request / response 模型的请求。\n  另外，基于其中的类型系统，"),t("a",{attrs:{href:"https://www.atatech.org/articles/137442?flag_data_from=home_follow_user_article",target:"_blank",rel:"noopener noreferrer"}},[a._v("数据模型的一致性"),t("OutboundLink")],1),a._v("也会通过类似这样的库 "),t("a",{attrs:{href:"https://web.npm.alibaba-inc.com/package/@ali/xux-types",target:"_blank",rel:"noopener noreferrer"}},[a._v("xux-types"),t("OutboundLink")],1),a._v(" 来逐步规整，沉淀成标准类型声明代码库。")]),a._v(" "),t("h4",{attrs:{id:"优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优势"}},[a._v("#")]),a._v(" 优势")]),a._v(" "),t("ol",[t("li",[a._v("开发体验：阅读简单，没有复杂的层层调用")]),a._v(" "),t("li",[a._v("开发提速：根据类型自动 mock，极大提升联调接口前的开发效率")]),a._v(" "),t("li",[a._v("开发提效：利用 ts 的阅读高效性，可以得到丰富的编译器代码提示、注释提示、编译警告等")]),a._v(" "),t("li",[a._v("开发提效：数据检查会自动发现潜在的类型信息问题，提升接口数据问题排查效率，避免空值、字段大小写错误这类低级错误")]),a._v(" "),t("li",[t("strong",[a._v("技术收敛")]),a._v("：同一类型的请求(ipc协议/tcp协议/ajax)等等，可以一次开发，提交 middleware 库之后0成本复用。")])]),a._v(" "),t("h2",{attrs:{id:"平台化到-no-code"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#平台化到-no-code"}},[a._v("#")]),a._v(" 平台化到 no-code")]),a._v(" "),t("p",[a._v("大量的接口管理，需要一个统一的接口管理平台去维护，这个平台上具备5个基础能力：接口自动化测试、数据模拟、接口文档、服务沉淀、描述与代码互转。")]),a._v(" "),t("ul",[t("li",[a._v("接口自动化测试：模拟前端动作，向服务端发起压力测试、边界 case 测试、故障 case 测试等")]),a._v(" "),t("li",[a._v("数据模拟：业务服务端未就绪时的 simulation")]),a._v(" "),t("li",[a._v("接口文档：文档化管理平台")]),a._v(" "),t("li",[a._v("能力沉淀：常用通用的业务服务，通过这个平台了解到前后端组合带来了哪些领域、哪些业务、哪些产品的模块。基于这些结果，我们将其再作为业务组件能力发布，可以被快速检索，可以被快速接入到新产品中。")]),a._v(" "),t("li",[a._v("描述与代码互转：这里包含三个角色：平台，服务端，前端，这三者的接口描述关系是可以互转的\n"),t("img",{attrs:{src:"/yuque/0/2019/svg/139763/1557332675161-0a6f1f9f-036f-4a5d-84d2-98a656adb565.svg",alt:""}})])]),a._v(" "),t("p",[a._v("在这个接口平台之上，构建数据模型描述(元数据)，创建数据操作(接口)，配合灵犀等数据到视图映射的工具，达到 low-code 甚至 no-code 的应用构建目的，也正如开篇提的 Dreamweaver 一类的工具了。")]),a._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),t("p",[a._v("说到底，程序应该是一套人机交互语言，是“让计算机能确切知道你想干什么”的描述语言，同时，也应具备“人类也能轻易阅读和理解”。在这个前提之下去构建一种 low-code，避免程序难处理、人也读不懂的局面。继而，构建no-code应用。\n  但是用户的使用体验是反过来的。先体验 no-code，希望做一些定制化的诉求时进入 low-code 的使用。到一定的专业程度，则会考虑专业的开发方式 pro-code，开发一些专业的单元模块，反哺 low-code 的能力单元，继而丰富 no-code 的能力。\n  在本文提到的前端接口方案表现的案例就是：使用平台配置接口 -> 低代码手动调用各种 middleware 串联 -> 贡献 middleware (例如接口协议) -> 丰富平台功能模块\n"),t("a",{attrs:{href:"https://www.atatech.org/articles/137897",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=r.exports}}]);